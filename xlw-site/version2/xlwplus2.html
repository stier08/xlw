<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">

<!--Converted with LaTeX2HTML 2002-2-1 (1.71)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>xlw 2.1 : a system for building xlls without pain
</TITLE>
<META NAME="description" CONTENT="xlw 2.1 : a system for building xlls without pain
">
<META NAME="keywords" CONTENT="xlwplus2">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META NAME="Generator" CONTENT="LaTeX2HTML v2002-2-1">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="xlwplus2.css">

</HEAD>

<BODY >
<H1 ALIGN=CENTER>
xlw 2.1 : a system for building xlls without pain
</H1>
<P ALIGN=CENTER><STRONG>Mark S. Joshi</STRONG></P>
<BR><P ALIGN=CENTER><I>Date:</I> May 11, 2008</P>
<BR><P ALIGN=LEFT><FONT SIZE=-1>Centre for Actuarial Studies, Department of Economics,
  University of Melbourne, Victoria 3010, Australia</FONT></P>
<P ALIGN=LEFT><FONT SIZE=-1><A NAME="tex2html1"
  HREF="mailto:mark@markjoshi.com">mark@markjoshi.com</A></FONT></P>
<BR><P><P ALIGN=LEFT><FONT SIZE=-1>Key words and phrases: EXCEL plug-in, xlw, parser</FONT></P>

<H1><A NAME="SECTION0001000000000000000000">
1 Introduction</A>
</H1>
Much numerical coding in quantitative finance is carried out in
C++. Much numerical work in finance is performed in EXCEL. It has
therefore become common to work with EXCEL plug-ins, that is with
programs that add functions to EXCEL, which allows easy input and output
to spreadsheets.

<P>
There are a number of ways to do this. For example, it can be done
using the COM framework. The most venerable way to do it is using
EXCEL's C API (application protocol interface), whilst this is many
ways archaic and Microsoft has not changed it since early versions of
EXCEL, it has the virtue that its stability has led to familiarity and
various packages have been develop to wrap it. One such package is xlw
(xlw.sourceforge.net). The xlw package provides an easy framework for
writing such plug-ins as dlls (dynamics link libraries) commonly known
as xlls. 

<P>
The xlw 2.1 package is an extension of xlw; its basic framework is the same but
various changes have been added to improve usability. The largest of these is
that rather than coding the registration and data conversion code in C++, a
parser routine has been written that takes in a header file and output a C++
source file with all the registration and data conversion already written. This
means that a user needs virtually no specialist knowledge in order to convert
any C++ routine into an xll.  

<P>
In addition, the original xlw was written to work with Visual Studio 6.0.
Support for Visual Studio 6.0 has been discontinued; this version comes with
project files for Visual Studio 7.1, 8.0, and 9.0, as well as for DevCpp
4.9.9.2.  DevCpp is a free IDE for the MinGW g++ compiler, and so XLLs can be
built using g++. 

<P>
A number of other more minor changes have been made: throws of strings and
similar objects are caught and passed back to EXCEL; failure of
arguments to convert to the correct data type throw strings
identifying the bad argument rather than ``#VALUE''; and new data
types of MyMatrix and CellMatrix are included. CellMatrix in
particular allows passing in a table of any cell-type that will arise,
i.e., numbers, strings, bools and error codes. It is also been made
easy to add customized data types provided they can be created from
existing types. 

<P>

<H1><A NAME="SECTION0002000000000000000000">
2 Usage</A>
</H1>

<P>
Before using xlw 2.1, one first has to build the xlw 2.1 library and
the interface generator. The interface generator project can be found
in directory appropriate for your compiler:

<UL>
<LI>For DevCpp look in the folder build/devcpp, and the project is
  called InterfaceGenerator.dev.
</LI>
<LI>For Visual Studio, open the solution build/vc?/xlw.sln, where
  ? is 7, 8, or 9 depending on your version of the compiler, and the
  project is called InterfaceGenerator. 
</LI>
</UL>
This project should be built and will produce a console application
called InterfaceGenerator.exe. Note one can use the version of this
application built with any one compiler with any other compiler
without trouble. 

<P>
Second one needs to build the xlw 2.1 library to link against. The
project files are in the same place as for the console application. 

<UL>
<LI>For DevCpp the project file is called xlw.dev, and the library
  file generated by this project is lib/xlw-gcc-s-3_0_0.a.
</LI>
<LI>For Visual Studio, the project is called xlw, and the library
  file generated by this project (Release configuration) is 
  lib/xlw-vc?-mt-3_0_0.lib.
</LI>
</UL>

<P>
For each compiler, an example project called ExampleAutogenerated is given,
defining functions to be exported to the xll.  Each project contains a header
file Test.h, a source file Test.cpp and an interface file xlwTest.cpp, these
are contained in the folder examples/autogenerated. Some files for payoffs can
also be found there, and example spreadsheets. 

<P>
It is the interface file xlwTest.cpp that has been automatically generated. To
re-generate it, simply ensure that InterfaceGenerator.exe is in the path or in
the same directory as Test.h and then at a command prompt type
``InterfaceGenerator Test.h''. 

<P>
The Visual Studio solutions contain an NMAKE project RunInterfaceGenerator
which detects changes to the inputs of InterfaceGenerator and reruns it
automatically as needed.

<P>
Simply building the xll project will then produce an xll, which can be
opened in EXCEL and produces extra functions in a library called
``MyTestLibrary.'' 

<P>
To use xlw 2.1 for your own functions, one should first write a C++ function
which compiles and builds except for the interfacing code. The functions to be
exported to EXCEL should be contained in header files which contain nothing
else. The InterfaceGenerator should then be applied to them. If the header file
is called ``MyFile.h'', the new file will be called ``xlwMyFile.cpp''. The new
file should then be added to the project. Note InterfaceGenerator will ignore
any preprocessor commands, and will throw an error if the header file contains
any classes or function definitions. It will also protest if any unknown data
types are found. 

<P>
The information for the function wizard in EXCEL is taken from comments and the
names of argument variables in the header file. This means that arguments must
be named. A comment should follow each argument name and this will appear in
the function wizard when that argument is being entered. The general
description of the function should be in a comment between the type of the
function and its name. 

<P>
Arguments can be passed by reference or by value, and can be const or
non-const. (In fact, these have no effect on the coding of the interface file.)

<P>
Once  the interface file has been added to the project, one simply builds the
project and then the output xll file should be openable by EXCEL. Note that one
can have any number of interface files in the same xll project. 

<P>
If you wish to create a new xll project, this can be done. The things
to do are 

<UL>
<LI>The folder containing the xlw folder must be on the include path.
</LI>
<LI>The folder containing the xlw library file must be on the linking
  path.
</LI>
<LI>The xlw library file must be on the list of files to link
  against.
</LI>
<LI>The project must be a dll project in DevCpp. (Create a dll
  project, remove the file created by DevCpp and then add your files.) 
</LI>
<LI>The project must use multi-threaded dll code generation in
  Visual Studio. 
</LI>
<LI>Change the name of the output file to MyName.xll. 
</LI>
</UL>

<P>
Note if you are working with Visual Studio 8.0 Express, in addition, you must do
the following:   

<UL>
<LI>Install the Microsoft SDK.
</LI>
<LI>Make sure the include directory includes the SDK one.
</LI>
<LI>Link against the following libraries: odbc32.lib
  odbccp32.lib User32.lib
</LI>
<LI>Directives in xlw header files will automatically generate the necessary
  dependency on the xlw lib file that corresponds to your compiler e.g.
  lib/xlw-vc80-mt-3_0_0.lib
</LI>
<LI>Make sure the SDK library directory is included on the list of
  directories to search for library directories. 
</LI>
<LI>When creating a new project, you must use create new project
  from existing code, and then later on say its a dll project. (This
  not an option when creating new projects from new code.)
</LI>
</UL>

<P>
Note some users have added a custom build step that causes the
InterfaceGenerator tool to run automatically. 

<P>

<H1><A NAME="SECTION0003000000000000000000">
3 Step by step guide for visual studio 8.0 express users</A>
</H1>

<P>
This was written by a user, and goes into more detail on how to  make
a new project using xlw. 

<UL>
<LI>Install SDK first, follow the instructions here
</LI>
<LI>You can open the InterfaceGenerator project directly from the folder and build it, this will give you the InterfaceGenerator.exe
</LI>
<LI>You can open the xlwLib directly from the folder and build it
</LI>
<LI>Create a new project using existing code, then choose dll project
</LI>
<LI>You can now add your function files or the files from the
  TestFiles folder.
</LI>
<LI>Once you have added your own files the C++ menu appears in
  the project properties. Make sure the folder containing the xlw
  folder is in the list of include directories.
</LI>
<LI>If you add your own files, put the InterfaceGenerator.exe in the same folder and than go to DOS command window, go to the directory and call: InterfaceGenerator myfile.h. This will generate a xlwmyfile.cpp, include this file in your project.
</LI>
<LI>Add the SDK folder in the Project Properties C/C++ Include menu.
</LI>
<LI>Add the xlw folder in the Project Properties C/C++ Include menu.
</LI>
<LI>Add the SDK/Lib folder in the Project Properties Linker Include libraries menu.
</LI>
<LI>Add the xlwLib/Debug folder in the Project Properties Linker Include libraries menu, if you're running the project in Debug mode.
</LI>
<LI>You have to add the following files in the Linker Input menu: odbc32.lib odbccp32.lib User32.lib xlwLib-Debug.lib, if you're running in debug mode
</LI>
<LI>You have to change the name in Linker Output menu to Debug/FDFunctions.xll, of whatever the name of your xll file is
</LI>
<LI>run the project, go to the Debug folder in your Project folder and you'll find the xll file there
</LI>
<LI>If your macros security level is to high, you won't see anything. Set it to middle or low. Now you can go to the insert functions menu and you should find the library and the functions.
</LI>
</UL>

<P>

<H1><A NAME="SECTION0004000000000000000000">
4 Basic Data-types</A>
</H1>

<P>
The function to be exported to EXCEL can only use data-types supported by the
interface generator. These are divisible into basic data types: double, short,
NEMatrix, MyMatrix, MyArray, CellMatrix, string, std::string, and bool, and
extended data types: int, unsigned long, ArgumentList, DoubleOrNothing, PayOff. 

<P>
Note the XLOPER type has two numeric data types which are essentially
short and double so other numeric types go via double. 

<P>
The class MyMatrix is defined via a typedef in MyContainers.h to
MJMatrix. You can use change this to your favourite matrix type. The
matrix class must support the following: it should have .rows()
and .columns() defined; a constructor that takes number of rows and
columns; and elements should be accessible via a[i][j]. If your matrix
class only supports element access via round brackets, you should
define the macro USE_PARENTHESES.

<P>
The class NEMatrix is a typedef for MyMatrix but if you declare an
argument to be of this type then the function will not be called
unless the argument is a non-empty matrix of numbers. (Otherwise, you
get #VALUE.) If you are working with very large matrices it should be
more stable as the data type is much simpler, (it uses type K for
passing instead of type P). 

<P>
The class MyArray is also defined via a typedef in MyContainers.h. The
default is to typedef to std::vector. It must have .size(), a
constructor taking the size and operator[] defined. 

<P>
CellMatrix is a new class declared in CellMatrix.h. It abstracts the
idea of a table of cell values in EXCEL. Thus each entry in the matrix
can have a value that is a string, number, bool, error value or
empty. This facilitates the passing of tables of mixed numbers and
strings. Conversion to a CellMatrix should virtually never fail since
it allows error codes. 

<P>
The types std::string and string are both allowed. These are the same
class and the difference is simply in whether the namespace std has
already been declared via using. 

<P>

<H1><A NAME="SECTION0005000000000000000000">
5 Extended data types</A>
</H1>

<P>
xlw 2.1 has been designed to make it easy to work with your own data
types. The only constraint is that a function (or method) must exist
that takes in a data-type that is already constructible from basic
types, and creates the new type. For this purpose, a constructor is
equivalent to a function. One simply adds a declaration in the file
TypeRegistrations.cpp. 

<P>
For example,
<PRE>
TypeRegistry::Helper arglistreg("ArgumentList",         // new type
                           "CellMatrix",                // old type
                           "ArgumentList",              // converter name
                           false,                       // is a method
                           true,                        // takes identifier 
                           "",                          // no key
                           "&lt;xlw/ArgList.h&gt;"            // force inclusion of this file
                           );


TypeRegistry::Helper payoffreg("Wrapper&lt;PayOff&gt;",       // new type
                           "ArgumentList",              // old type
                           "GetFromFactory&lt;PayOff&gt;",    // converter name
                           false,                       // is a method
                           false,                       // takes identifier 
                           "" ,                         // no key
                          "&lt;xlw/ArgListFactory.h&gt;"
                           );
</PRE>

<P>
The first argument is the identifier for the new type.

<P>
The second is the type which the new type is constructed from. 

<P>
The third is the function or method used to construct the new type
from the old one. 

<P>
The first bool is to specify whether the conversion function is a
method of the old class, or simply a function or constructor that
takes in an object of the old class. 

<P>
The second bool indicates whether the converter method or function
takes in a second argument which is a string expressing an identifier
in case of error - this is very handy when trying to work out which
argument in your complicated function is dubious. 

<P>
The key is to tell EXCEL the type, this is generally only used when converting
from XlfOper, i.e. when defining a basic type. This is typically ``R''
or ``P''. Doubles are passed as type ``B'' and non-empty matrices as ``K.''

<P>
The last argument allows the forcing of extra #includes in your .cpp
interface file. This allows you to ensure that the conversion function
is available. 

<P>
You define new types from other new types. The maximum depth is 26, at
which point the parser concludes that you have accidentally created a
loop. 

<P>
The three main data types that have been added for illustration are the
DoubleOrNothing, ArgumentList and Wrapper&lt;PayOff&gt;. 

<P>
The DoubleOrNothing class allows one distinguish between a number passed in
or an empty argument. One can therefore choose between a number passed
in, and a default value if the argument is empty. 

<P>
The argument list takes in a table of cells and turns it into a
collection of arguments. This allows the passing of a variable number of
arguments within one function argument. The top left of the table must be
the name of the structure e.g. PayOff. Within the table, the types
number, string, array, matrix, cells and list can be used. For each of
these one gives a name and then the data below. For an array, the size
of the array should be specified directly below the name. For a
matrix, cells, and list the number of rows and columns should be given
directly below. The type cells is simply a matrix of cell values. The
type list is an ArgumentList. The use of
ArgumentLists inside ArgumentLists is very useful for doing
decoration and composite patterns. Note that everything passed in to an
ArgumentList is put into lower case. 

<P>
The ArgumentList is particularly powerful with factories. We have
 provided a templatized factory that takes in an ArgumentList, and can be
 used for arbitrary types. The only restrictions are that the
 inherited types have constructors that take in an ArgumentList, and
 that they have a common base class.  
 We illustrate this with the PayOff class. 

<P>
The factory returns a raw pointer to the base class, so this should be
immediately converted to a smart pointer (if you don't you will get
memory leaks) so we use a polymorphic copying pointer,
Wrapper. However, one could use a boost::shared_ptr or a
std::auto_ptr. Our new data type is therefore 

<P>
<PRE>
Wrapper&lt; PayOff &gt;
</PRE>

<P>
, which takes ownership and ensures deletion at the appropriate time. 

<P>
Examples of how to use this class are given in the spreadsheet
examples/autogenerated/Example.xls.

<P>

<H1><A NAME="SECTION0006000000000000000000">
6 xlw commands</A>
</H1>

<P>
The default name of the Library in Excel is the name of the header
file. You can change this by

<P>
<PRE>
//&lt;xlw:libraryname=MyTestLibrary
</PRE>

<P>
in the header file. Note that all functions in the header file will have
the same library name which will be that specified by the last
libraryname command. 

<P>
If you want a volatile function then this can be done as follows:

<P>
<PRE>
double // system clock
//&lt;xlw:volatile    
SystemTime(DoubleOrNothing ticksPerSecond // number to divide by
                   );
</PRE>

<P>
A volatile function is a function whose value can change even if the
arguments have not - typically random numbers or time. 

<P>
You can also time functions by inserting 
<PRE>
//&lt;xlw:time
</PRE>
in the same place. (Yes, volatile functions can be timed, the order of
the two commands is not important.)

<P>

<H1><A NAME="SECTION0007000000000000000000">
7 The interface file</A>
</H1>

<P>
It is not necessary to ever look at the interface file. However, it
can be edited directly if so desired. It first has a DummyFunction
declared in an unnamed namespace. This function references the
functions xlAutoOpen and xlAutoClose and thus forces their inclusion
in the xll. These functions carry out the registration of the other
functions with EXCEL and are therefore essential. 

<P>
There is a line
<PRE>
const char* LibraryName = "MyTestLibrary";
</PRE>
This specifies the name of the library in the EXCEL function
wizard. This is enclosed in an anonymous namespace so you can have
multiple interface files. 

<P>
For each function, there are two parts. The first is the registration
information. The second is the wrapper function called between EXCEL
and the function chosen. 

<P>
An example of the registration information is 
<PRE>
namespace
{
XLRegistration::Arg
ConcatArgs[]=
{
{ "str1"," first string "},
{ "str2","second string "}
};
  
XLRegistration::XLFunctionRegistrationHelper
registerConcat("xlConcat",
"Concat",
" Concatenates two strings ",
LibraryName,
ConcatArgs,
"RR");
}
</PRE>

<P>
The code is placed in an unknown namespace to ensure it does not
affect any linkage. The arguments are declared in the first part, with
the name of each followed by its description. 

<P>
In the second part, a global variable is declared. The creation of
this global variable registers the function with a global singleton,
which ensures that it is registered with EXCEL. This approach allows
the registration to be split across many files. The information passed
to the constructor is the name of the function in C++ in the interface
file, the name of the function in the function in EXCEL, the function
description, the name of the library in EXCEL, the arguments declared
above and the types of the arguments. The types are expressed via a
code: e.g. 

<UL>
<LI>R - XLOPER by reference (LPXLOPER)
</LI>
<LI>P - OPER by reference
</LI>
<LI>B - double
</LI>
<LI>K - floating point array
</LI>
</UL>

<P>
In xlw 2.1, only the types P, B, K, and R are used. P is used for CellMatrix
and MyMatrix. K is used for NEMatrix. B for double. 
R is used for all other basic types. Types such as bool 
are therefore first passed in as LPXLOPERs and then transformed
into the right data type. 

<P>
An example of the interface function definition is 

<P>
<PRE>
extern "C"
{
LPXLOPER EXCEL_EXPORT
xlConcat(
LPXLOPER xlstr1_,
LPXLOPER xlstr2_)
{
EXCEL_BEGIN;

if (XlfExcel::Instance().IsCalledByFuncWiz())
     return XlfOper(true);

XlfOper xlstr1(xlstr1_);
std::string str1(xlstr1.AsString("str1"));

XlfOper xlstr2(xlstr2_);
std::string str2(xlstr2.AsString("str2"));

std::string result(
        Concat(
                str1,
                str2)
        );
return XlfOper(result);
EXCEL_END
}
}
</PRE>

<P>
The extern `C' command is necessary as we are using the C API and
therefore must use C linkage. 

<P>
The return type of the function is always LPXLOPER but since this is a
polymorphic data type, this is not a hindrance.  EXCEL_EXPORT is a
macro:
<PRE>
#define EXCEL_EXPORT __declspec(dllexport)
</PRE>
This ensures that the function is a dll export, and so can be
dynamically linked against. 

<P>
Note that types are passed in as LPXLOPERs not XlfOpers or other
types. XlfOpers are not used since they cause a crash with the MinGW
compiler as they are not POD objects. 

<P>
The macros EXCEL_BEGIN and EXCEL_END contain starting and finishing
information common to all function. In particular, EXCEL_END contains
catches for common data types to return information to EXCEL. 

<P>
The routine then checks if it is being called from the function
wizard. If it is, then it immediately returns to EXCEL. This avoids
time consuming computations being called whilst data is being
entered. 

<P>
Each argument is then converted. First to an XlfOper, and then using
the .As methods to the correct type. Note a string is passed into the
.As method, this allows a throw to identify the offending argument. If
you use extended types there will be a string of conversions here. 

<P>
Once the arguments have been converted, the original function is
called and the result stored. For return to EXCEL, it is converted
into an XlfOper and this is returned as an LPXLOPER.

<P>

<H1><A NAME="SECTION0008000000000000000000">
8 The interface generator</A>
</H1>

<P>
The interface generator is written as a simple C++ routine. It is a
console application that takes in one argument. The output file name
is an optional argument and it defaults to adding ``xlw'' on the front
and ``.cpp'' at the end.

<P>
The routine first reads in the file and places it in a vector of chars
for convenience. It is then turned into tokens. Each token will be an
identifier, preprocessor directive,  comment or delimiter. 

<P>
Tokens corresponding to consts and ampersands are then removed, since
they will not affect the coding of the interface routine. At this
stage, unsigned identifiers are also dealt with. 

<P>
Once this has been done, the file is turned into a list of functions,
with each function having a list of arguments with names and types.

<P>
The next operation is to identify all the types and find the
conversion routines. 

<P>
Once this has been done, the output file is written into a vector, and
then written to a file. 

<P>

<H1><A NAME="SECTION0009000000000000000000">
9 Troubleshooting</A>
</H1>

<P>
If you find that you can build the xll but that the functions do not
register. Here are some common problems with xlls in general. 

<P>
If absolutely nothing happens then check security settings for
macros. The default setting is to ignore files containing macros. Note
for a reasonable level of security setting, you will get asked whether
to enable macros, if this does not happen then security levels are too
high (or too low!)

<P>
If you get the unrecognizable format error, possibilities are

<P>

<UL>
<LI>Missing dlls on your machine. This often occurs if you compile
  in VC on one machine and then move the xll to another one. This can
  be cured either by working out how to get the compiler not to need
  the dlls, or by copying the required dlls to the new machine. (or
  switch to using DevCpp.) 
</LI>
<LI>Failure to export the auto open and auto close functions. 
</LI>
</UL>

<P>
The dumpbin utility can be used to check whether the right functions
are being exported. If you have followed the instructions here, this
<EM>should</EM> not be an issue.
<BR><HR>
<ADDRESS>
erik
2008-05-11
</ADDRESS>
</BODY>
</HTML>
