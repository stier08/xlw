



This is a note to contributors


 xlw.NET allows the developer to write Excel addins ( proper xll addins not COM addins ) in C# 
( an hence in any of the .NET languages ) and is  adequatley functional as of now ( 10/2008 ).
It is however far from polished. An initial fully working version was up in 4days  to meet 
the requirements of a project with limited time resources. 

This has meant that for now:

	1. It has only be compiled on Visual Studio 2008 Pro. It relies on the ability of a
           VS solution to be able to contain a C++ project and a C# project. ( I am not
           sure whether the Exprees edition allows this) 

	2. Unlike for xlw, xlw.NET will not compile under gcc, this is because essential parts are 
           written in C++/CLI

        3. The DotNetInterafaceGenerator has to be completely refactored and made object oriented
           to make it mush easier to add new types ( so get rid of the if ... else 's )

        4. It is not sufficiently tested
 
        5. In the managed Wrappers ( .NET wrappers for classes in xlw ) not all the methods have been
           wrapped.

        ... etc etc 


The goal is, in time to incorporate xlw.NET into the main xlw project 


-----------------------------------------------------------------------------------------------------

The process by which C# xlls are produced are as follows


1. i. Write your C# functions in a C# Assembly and decorate
each function with the attribute
ExcelExportAttribute["function description goes here")]

ii. Decorate each parameter with the attribute
ParameterAttribute["parameter description goes
here "]

iii. Ensure the function is public and static.

iv. Build the assembly and register with gacutil.exe with
the Global Assembley Cache.

The above step gives us MyLib.NET.dll



2 Run the program (actualy its a post-build event)
DotNetInterfaceGenerator.exe (which I have written) that
uses reflection to parse you Assembley of function and
generate a .h and a .cpp file of C++ bindings for the C#
functions. The .h file is is in the appropriate format for
input into InterfaceGenerator.exe thats shipped with xlw.
Build the cpp file into a DLL that __declspec(dllexports)'
the Cfunctions

The above step gives us MyLibC.dll




3 Using InterfaceGenerator.exe parse the .h file from step
2 and build the resulting source files into our xll

The above step gives us MyLib.xll


We therefore have three dlls : MyLib.NET.dll, MyLibC.dll &
MyLib.xll, all of which are interdependant.


All the work for the above steps I have completed as well as
exporting MyArray, MyMatrix, CellMatrix and ArgumentList to
C#, giving native C# classes.
I have built an xll that can evaluate all the cells, expect
a few ( e.g doubleornothing) in the example spreadsheet
shipped with the AutoGenerated xll in xlw.

To clarify, the reason the C functions generated in step 2
are put in a dll of their own instead of being put directly
in the .xll is because they are wriiten in mixed ( managed
and unmanaged ) code and the xll won't work if it is
compiled with /clr compile option.


Narinder Claire

      

 