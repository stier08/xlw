
/*! \page version3 XLW Version 3 - Support for Excel 2007

\section v3_summary Summary

xlw is upgraded to support new features of Excel 2007 such as

\li longer strings
\li Unicode
\li larger spreadsheets
\li multithreading
\li additional function arguments

Certain new features of Excel 2007 such as larger spreadsheets and long/Unicode
strings can be exposed by xlw to its client applications with no change to the
xlw interface. When the Addin is loaded, the core xlw library detects the
version of Excel under which the XLL is being run, and dynamically supports the
new features where possible with no need for changes to legacy source code of
xlw client applications. Other new Excel 2007 features such as multithreading
necessitate enhancements to the xlw interface and modifications must be made to
source code of client applications in order to exploit these new features.

\section v3_terminology Terminology

Excel version 4 introduced the Excel C API, which remained largely unchanged
through Excel version 11 (also known as Excel 2003). Excel version 12 (Excel
2007) introduces fundamental enhancements to the API. Hereafter Excel 12 refers
to Excel 2007 and Excel 4 refers collectively to all versions of Excel prior to
Excel 2007.

\section v3_objectives Objectives

The screenshots below summarize the main objectives of the xlw version 3
release.

\subsection v3_ss4 Excel 4

\image html screenshot4.jpg

\subsection v3_ss12 Excel 12

\image html screenshot12.jpg

\subsection v3_explanation Explanation

The screenshots above display the output from a single xlw XLL which is
compiled from a single source code base and is compatible both with Excel 4 and
Excel 12.

The application implements three variations of a "Concat()" function. Each
variation of the function is called once with ASCII input (supported by Excel 4
and 12) and once with Unicode input (supported by Excel 12 only).

<table>
<tr>
<td><b>Function</b></td><td><b>Description</b></td></tr>
<tr>
<td><b>Concat()</b></td><td><ul>
<li>Functions both with Excel 4 and 12</li>
<li>Supports Unicode if run under Excel 12</li>
</ul>
</td></tr>
<tr>
<td><b>Concat4()</b></td><td><ul>
<li>Functions both with Excel 4 and 12</li>
<li>Retains Excel 4 behavior (no Unicode support) even when run under Excel 12</li>
</ul>
</td></tr>
<tr>
<td><b>Concat12()</b></td><td><ul>
<li>Supports Unicode</li>
<li>Available only in Excel 12</li>
</ul>
</td></tr>
</table>

Function Concat() reflects the primary objectives for the xlw upgrade. The
function retains old Excel 4 compatible behavior if run under Excel 4, but when
called from Excel 12 the same function picks up new Excel 12 functionality, in
this case Unicode support.

The flexibility in function Concat() incurs a performance overhead at run time.
This overhead is avoided in functions Concat4() and Concat12() which target
specific versions of Excel.

\section v3_xlfoper Class XlfOper - Original Design

The crux of the xlw design is that class XlfOper, the wrapper for Excel's
XLOPER datatype, shares the same memory footprint as LPXLOPER (XLOPER*).
XlfOper declares a single data member of type LPXLOPER such that
sizeof(XlfOper) = sizeof(LPXLOPER).

\code
class XlfOper {
    LPXLOPER lpxloper_;
public:
    std::string AsString();
    //...
};
\endcode

LPXLOPERs passed from Excel to the Addin are received by Addin functions into
arguments of type XlfOper. Consider xlw example function xlConcat(), which
accepts as input two strings which are concatenated and returned. This function
is registered with Excel such that Excel thinks the datatype of the input
parameters is LPXLOPER.

\code
LPXLOPER xlConcat(LPXLOPER xlStr1, LPXLOPER xlStr2);
\endcode

In fact the function is declared as accepting input parameters of type XlfOper.

\code
LPXLOPER xlConcat(XlfOper xlStr1, XlfOper xlStr2);
\endcode

Excel passes arguments of type LPXLOPER, which are received by the function
into parameters of type XlfOper.  The XlfOper constructor is not invoked, the
LPXLOPER value passed by Excel simply populates the LPXLOPER data member of
the XlfOper argument. XlfOper's member functions then serve as functionality
bound to that reference, and the implementation of xlConcat() accesses the
LPXLOPER via its XlfOper wrapper.

\code
std::string str1 = xlStr1.AsString();
\endcode

The operation above exploits the fact that no type checking is performed in
this call across DLL boundaries.  This is undefined behavior, which happens to
work with all versions of Visual C++ (so far) but there is no guarantee that
any compiler should support this feature and in particular MinGW (gcc) does
not.  Mingw stores PODs (such as LPXLOPER) differently than user defined types
(such as XlfOper), and when compiled with MinGW the above code crashes at
runtime.

An additional conversion is required to achive type safety.

\code
LPXLOPER xlConcat(LPXLOPER xlStr1, LPXLOPER xlStr2) {
    XlfOper xlfStr1(xlStr1);
    XlfOper xlfStr2(xlStr2);
    std::string str1 = xlfStr1.AsString();
    std::string str2 = xlfStr2.AsString();
    //...
}
\endcode

\section v3_constraints Constraints

xlw is enhanced to support Excel 12, in which LPXLOPER is deprecated in favor
of LPXLOPER12 (XLOPER12*) which has a modified structure in support of larger
spreadsheets, longer strings, and other Excel 12 features.

To ensure a smooth transition for xlw client applications, xlw is enhanced
within constraints:

\li No legacy code of xlw client applications is broken i.e. changes to the
    xlw interface are backward compatible
\li During runtime initialization of the client XLL, the core xlw library
    detects the version of Excel and XlfOper then proxies LPXLOPER or
    LPXLOPER12 as appropriate

Without modification, client xlw applications when loaded by Excel 12 silently
pick up enhanced features such as larger range references, while preserving
existing behavior when run under older versions of Excel. It is of course
necessary to recompile the client application against the new version of xlw.
Additional features of Excel 12 such as multithreading are exposed by xlw
through additional properties in the xlw interface and xlw client apps require
enhancement to invoke such new features.

\section v3_newdesign Class XlfOper - New Design

Class XlfOper is enhanced to allow it to occupy the memory footprint of either
LPXLOPER or LPXLOPER12.

\code
class XlfOper {
    union { 
        LPXLOPER lpxloper4_;
        LPXLOPER12 lpxloper12_;
    };
public:
    double AsDouble();
    //...
};
\endcode

Now the class requires run time logic to determine which pointer to
dereference. Ideally the switch is implemented via polymorphism, e.g. some
abstract notion of an LPXLOPER, concretely instantiated as either LPXLOPER (4)
or LPXLOPER12 depending on which version of Excel is detected. But no virtual
function can be added to class XlfOper because the corresponding vtable would
result in XlfOper no longer being bitwise equivalent to LPXLOPER.

The logic around the LPXLOPER/LPXLOPER12 reference is passed off to friend
class XlfOperImpl. XlfOper can't hold a reference to XlfOperImpl so instead
the latter is implemented as a polymorphic Singleton, an abstract base class
which is instantiated at runtime by one of two concrete derived classes,
XlfOperImpl4 or XlfOperImpl12, depending on which version of Excel is
detected at startup.

\code
class XlfOperImpl {
    static XlfOperImpl *instance_;
public: 
    static XlfOperImpl &instance() { return *instance_; }
    XlfOperImpl() { instance_ = this; }
    virtual double AsDouble(const XlfOper &xlfOper) = 0;
};  

class XlfOperImpl4 : public XlfOperImpl {
    virtual double AsDouble(const XlfOper &xlfOper) {
        return xlfOper.lpxloper4_->val.num;
    }   
};

class XlfOperImpl12 : public XlfOperImpl {
    virtual double AsDouble(const XlfOper &xlfOper) {
        return xlfOper.lpxloper12_->val.num;
    }
};
\endcode

Calls to XlfOper are forwarded to XlfOperImpl for execution by the appropriate
derived class.

\code
double XlfOper::AsDouble() {
    return XlfOperImpl::instance().AsDouble(*this);
}
\endcode

\section v3_usage Usage

Consider legacy code from xlw client applications:

\code
LPXLOPER xlCirc(XlfOper xlDiam) {
    double diam = xlDiam.AsDouble();
    //...
}
\endcode

Or the alternative implementation where mingw support is required:

\code
LPXLOPER xlCirc(LPXLOPER xlDiam) {
    XlfOper xlDiam2(xlDiam);
    double diam = xlDiam2.AsDouble();
    //...
}
\endcode

The above code can be compiled without amendment under the new version of xlw
into an XLL which is compatible with both Excel 4 and 12. The type XlfOper
when run under Excel 12 automatically picks up support for Excel12 features.
However both of the code examples above contain explicit references to the
Excel 4 datatype LPXLOPER, and in those places the code does not acquire Excel
12 functionality.

Full interoperability requires a function which implements the LPXLOPER type
when run under Excel 4 and the LPXLOPER12 datatype when run under Excel 12.
This flexibility is achieved through use of the void* type, which accepts
LPXLOPER or LPXLOPER12 depending on the version of Excel detected at runtime.
The following typedef serves to clarify the intentions of the code:

\code
typedef void* LPXLFOPER;
\endcode

The function may then be implemented as

\code
LPXLFOPER xlCirc(LPXLFOPER xlDiam) {
    XlfOper xlDiam2(xlDiam);
    double diam = xlDiam2.AsDouble();
    //...
}
\endcode

When running under Excel 4, xlw registers the above function as receiving and
returning LPXLOPER. When running under Excel 12, xlw registers the above
function as receiving and returning LPXLOPER12. The single source code
implementation serves in either case and when run under Excel 12 the code
dynamically picks up support for Excel 12 features.

Where mingw compatibility is not a concern, the code can be simplified to

\code
LPXLFOPER xlCirc(XlfOper xlDiam) {
    double diam = xlDiam.AsDouble();
    //...
}
\endcode

\section v3_xloper_4_12 XlfOper4 and XlfOper12

The proposed new implementation of XlfOper allows for a seamless upgrade, at
the cost of some runtime performance. The cost is not warranted for
applications that know they always require LPXLOPER or LPXLOPER12, and so new
classes XlfOper4 and XlfOper12 are provided to map directly to those types.

The table below summarizes the advantages and disadvantages of the supported
interfaces.

<table>
<tr>
<td><b>Class</b></td><td><b><center>+</center></b></td><td><b><center>-</center></b></td></tr>
<tr><td><b>XlfOper</b></td><td><ul>
<li>Automatically encapsulates either LPXLOPER or LPXLOPER12</li>
<li>Backward compatible with old XlfOper class</li></ul></td><td><ul>
<li>Incurs a run time overhead. Each member function forwards its call to a virtual function in the XlfOperImpl singleton.</li></ul></td></tr>
<tr><td><b>XlfOper4</b></td><td><ul>
<li>Backward compatible with old XlfOper class</li>
<li>No performance overhead compared to old XlfOper
class</li></ul></td><td><ul>
<li>Encapsulates LPXLOPER only</li>
<li>Supported by Excel 12 but invokes none of Excel 12's new features</li></ul></td></tr>
<tr><td><b>XlfOper12</b></td><td><ul>
<li>No performance overhead compared to old XlfOper class</li></ul></td><td><ul>
<li>Encapsulates LPXLOPER12 only</li>
<li>Not supported by Excel 4</li></ul></td></tr>
</table>

\section v3_references References

<a href="http://xlw.sourceforge.net/xlwplus2.pdf">XLW 2.1 : A System For Building XLLs Without Pain - Mark S. Joshi</a><br>
<a href="http://xlw.sourceforge.net/html/index.html">XLW Version 1 Documentation</a><br>
<a href="http://msdn2.microsoft.com/en-US/library/aa730920.aspx">Developing Add-ins (XLLs) in Excel 2007</a>

*/

